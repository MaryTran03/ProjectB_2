# -*- coding: utf-8 -*-
"""monteCarloPi

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vAnMSWBx2UMEDjV8Wi6_YOhEJcuxES4F
"""

#monteCarlopPi.py
# import sys, random, and pandas modules
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#class begins: MonteCarloPi()
class MonteCarloPi:
    '''
      A class to store

      Attributes:
        radius (int): the radius of the square the
        length (int): size of the square the darts are thrown in
        num_it (int): number of iterations
        num_darts (int): number of dart throws, randomly selected from range (100, 10000)

    '''

    # constructor w params, self, radius, num_it
    def __init__(self, radius=1, num_it=100, num_darts_range=(100, 10000)):
        self.radius = radius
        self.length = 2 * radius
        self.num_it = num_it
        self.num_darts_range = num_darts_range
        self.results_df = pd.DataFrame(columns=['Iteration', 'Throws', 'Hits', 'Pi Estimate'])



        # assigns num_darts as a randome int between 100 and 10000

    # method throw_dart

        '''
          throw_dart is a method for Class MonteCarloPi

          returns boolean for if the throw landed inside the circle

        '''
    def throw_dart(self):
        x, y = np.random.uniform(-self.radius, self.radius, 2)
        return x**2 + y**2 <= self.radius**2
        # get a float between 1.0 and 10.0

        # if float is > 1.0 and < 7.85, dart landed inside the circle
        
        # else circle = False
    
    # method many_throws()

        '''
          many_throws is a method for Class MonteCarloPi

          it creates dataframe for the Object

        '''
        # create empty throws_list

        # for all num_darts append result of throw_dart() to list

        # create a dataframe from throws_list

        # return dataframe (aarya made a change)
    
    def many_throws(self):
        for iteration in range(1, self.num_it + 1):
            num_darts = np.random.randint(*self.num_darts_range)
            hits = sum(self.throw_dart() for _ in range(num_darts))
            pi_estimate = 4 * hits / num_darts
            self.results_df = self.results_df.append({'Iteration': iteration, 'Throws': num_darts, 'Hits': hits, 'Pi Estimate': pi_estimate}, ignore_index=True)


  # method summarize_results()

        '''
          summarize_results is a method for Class MonteCarloPi

          returns number of hits inside and outside the circle in hit_results_df

        '''
        # return value_counts() of column in df
    def summarize_results(self):
        return self.results_df.describe()

  # method calc_pi() 
  # w param hit_results_df

      '''
        calc_pi is a method for Class MonteCarloPi

        it calculates pi based on the area of a circle and the area of a square:
          pi = 4*hit_results_df[0]/(hit_results_df[0] + hit_results_df[1])

      '''
    def calc_pi(self):
        mean_pi = self.results_df['Pi Estimate'].mean()
        std_error = self.results_df['Pi Estimate'].std() / np.sqrt(self.num_it)
        return mean_pi, std_error
      # return pi
    def visualize_simulation(self):
        plt.scatter(self.results_df['Throws'], self.results_df['Pi Estimate'])
        plt.xlabel('Number of Throws')
        plt.ylabel('Pi Estimate')
        plt.title('Monte Carlo Simulation of Pi')
        plt.show()

# Usage example
monte_carlo_pi = MonteCarloPi()
monte_carlo_pi.many_throws()
print(monte_carlo_pi.summarize_results())
mean_pi, std_error = monte_carlo_pi.calc_pi()
print(f"Estimated Pi: {mean_pi} Â± {std_error}")
monte_carlo_pi.visualize_simulation()
